# 프록시와 연관관계 관리

# 프록시

연관된 객체들을 데이터베이스에서 조회하기 위해 사용한다.

연관된 객체들을 처음부터 데이터베이스에서 조회하는 것이 아닌, 실제 사용하는 시점에 데이터베이스에서 조회할 수 있다.

```java
em.find() //데이터베이스를 통해서 실제 엔티티 객체 조회
em.getReference()  //데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
```

<aside>
👩🏻‍💻 **복습**

**em.persist()** : 영속성 컨텍스트에 쿼리 저장

**em.flush()** : 영속성 컨텍스트에 있는 데이터를 DB까지 접근시키지만, commit은 아님.

**em.clear()** : 영속성 컨텍스트에 데이터를 제거

</aside>

## 프록시 특징 1

- 실제 클래스를 상속받아 만들어짐.
- 사용하는 입장에선 진짜 객체인지 프록시 객체인지 구분하지 않고 사용함.
- 프록시 객체를 호출하면 실제 객체의 참조(target)를 보관하고 있다가 실제 객체의 메소드를 호출.

## 프록시 객체의 초기화

`member.getName()`처럼 실제 사용될 때 데이터베이스를 조회해서 실제 엔티티 객체를 생성하는 것을 말함.

---

1. 프록시 객체에 member.getName() 호출해서 실제 데이터를 조회
2. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에서 실제 엔티티 생성을 요청(초기화)
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성
4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 Member target 맴버 변수에 보관
5. 프록시 객체는 실제 엔티티 객체의 getName()을 호출해서 결과를 반환

---

## 프록시 특징 2

- 프록시 객체는 처음 사용할 때 한 번만 초기화
- 초기화 시, 프록시 객체가 **실제 엔티티로 바뀌는 것이 아님**. 초기화되면 프록시 객체를 통해 **실제 엔티티에 접근 가능**
- 프록시 객체는 원본 엔티티를 상속받아 타입 체크 시 주의해야함.
**(== 비교 실패, 대신 instance of 사용)**
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 **em.getReference()를 호출해도 실제 엔티티 반환**
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생.

<aside>
💡 **instance of**

참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다.

**instanceof 왼쪽에는 참조변수, 오른쪽에는 타입(클래스명)이 피연산자로 위치**

연산의 결과로 True, False 중의 하나를 반환

</aside>

<aside>
👩🏻‍💻 **복습 : 준영속 상태**

영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 것을 준영속 상태라 한다.

- 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.
- **준영속 상태로 만드는 방법**
1. em.detach(entity) : 특정 엔티티만 준영속 상태로 전환한다.
2. em.clear() : 영속성 컨텍스트를 완전히 초기화한다.
3. em.close() : 영속성 컨텍스트를 종료한다.
</aside>

## 프록시 확인

JPA가 제공하는 `PersistenceUtil.isLoaded(Object entity)`메소드를 사용하면 프록시 인스턴스의 초기화 여부를 확인 할 수 있습니다. 

아직 초기화되지 않는 프록시 인스턴스는 **false**를 반환한다. 이미 초기화되었거나 프록시 인스턴스가 아니면 **true**를 반환합니다.

JPA 표준에는 프록시 강제 초기화 메소드가 없으나, 하이버네이트에서 `initalize()` 메소드를 통해 강제 초기화 메소드를 제공한다.

# 즉시 로딩과 지연 로딩

JPA에서는 데이터를 조회할 때 즉시 로딩(EAGER)과 지연 로딩(LAZY) 두 가지 방식이 있다. 

이 두 가지 방식을 간단하게 설명하면 **즉시 로딩**은 데이터를 조회할 때 연관된 데이터까지 한 번에 불러오는 것이고, **지연 로딩**은 필요한 시점에 연관된 데이터를 불러오는 것이라고 할 수 있다.

- @ManyToOne, @OneToOne : 기본이 **즉시 로딩**
- @OneToMany, @ManyToMany : 가본이 **지연 로딩**

> *가급적이면 **지연 로딩**만 사용*
> 

즉시 로딩을 적용하면 예상하지 못한 SQL이 발생한다. → 상상하지 못한 쿼리가 나갈 수도 있음.

JPQL fetch 조인이나, 엔티티 그래프 기능을 사용하는 것이 좋다.

<aside>
💡 **fetch 조인**

JPA에서 일반적인 조인을 사용하면 연관된 엔티티는 함께 조회하지 않는다. 그렇기 때문에 N+1 문제가 발생할 수 있는데, **fetch 조인**을 사용하면 연관된 엔티티를 한 번의 쿼리로 모두 가져올 수 있다.

👀 N+1 문제란 하나의 쿼리를 날리는데 조회되는 결과의 개수만큼의 쿼리가 추가적으로 나가는 것

</aside>

# 영속성 전이 : CASCADE

***연관관계를 매핑하는 것과 관련이 없으며, 엔티티를 영속화할 때 연관된 엔티티고 함께 영속화하는 편리함을 제공할 뿐이다.***

부모 엔티티가 영속화될 때 자식 엔티티도 같이 영속화되고, 부모 엔티티가 삭제될 때 자식 엔티티도 삭제되는 등 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 전이되는 것을 의미한다.
(@OneToMany 나 @ManyToOne에 옵션으로 줄 수 있는 값이다.)

```java
@OneToMany(mappedBy="parent", cascade=CascadeType.PERSIST)
```

- **CascadeType.ALL: 모든 Cascade를 적용**
- **CascadeType.PERSIST: 엔티티를 영속화할 때, 연관된 엔티티도 함께 유지**
- CascadeType.MERGE: 엔티티 상태를 병합(Merge)할 때, 연관된 엔티티도 모두 병합
- **CascadeType.REMOVE: 엔티티를 제거할 때, 연관된 엔티티도 모두 제거**
- CascadeType.DETACH: 부모 엔티티를 detach() 수행하면, 연관 엔티티도 detach()상태가 되어 변경 사항 반영 X
- CascadeType.REFRESH: 상위 엔티티를 새로고침(Refresh)할 때, 연관된 엔티티도 모두 새로고침

# 고아 객체

부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동 삭제.

참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제한다. 

@OneToOne, @OneToMany만 가능하다.

`**🔥 참조하는 곳이 하나일 때 사용해야함!**`

- **orphanRemoval = true**
- `Parent parent1 = em.find(Parent.class, id);parent1.getChildren().remove(0);`
자식 엔티티를 컬렉션에서 제거함 ➡ 부모객체와의 연관관계 끊어짐
- `DELETE FROM CHILD WHERE ID = ?` ➡ DELETE 쿼리 발생한다.

# **영속성 전이 + 고아객체, 생명주기**

```java
CascadeType.ALL + orphanRemoval=true
```

두 옵션을 모두 활성화하면 **부모 엔티티를 통해서 자식 엔티티의 생명주기를 관리**할 수 있다.

- parent와 달리 child는 생명주기를 부모 엔티티가 관리
- 굳이 DB로 따지면 DAO나 Repository가 없어도 된다는 의미
- 생명주기를 부모가 관리하기 때문에
