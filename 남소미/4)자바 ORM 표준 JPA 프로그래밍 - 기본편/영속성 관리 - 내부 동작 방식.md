## JPA에서 가장 중요한 2가지

- 객체와 관계형 데이터베이스 매핑하기
- 영속성 컨텍스트

<img width="433" alt="1" src="https://github.com/LAB-2023/LAB_study/assets/125250173/6504862d-7617-459d-80ae-61410234db06">

## 영속성 컨텍스트

“엔티티를 영구 저장하는 환경”

논리적인 개념이기에 눈에 보이지 않고, **EntityManager**를 통해 접근할 수 있다.

## 엔티티의 생명주기

- 비영속 : 새로운 상태
- 영속 : 관리되는 상태
- 준영속 : 저장되었다가 분리된 상태
- 삭제
    
    <img width="707" alt="2" src="https://github.com/LAB-2023/LAB_study/assets/125250173/34be83e3-4f99-4ea1-b561-56aacd14d2f0">

### 비영속 : JPA와 상관없는 상태

<img width="296" alt="3" src="https://github.com/LAB-2023/LAB_study/assets/125250173/c1683cb8-f99e-4fa8-942c-645608fc5573">

### 영속 : DB에는 저장되지 않음

<img width="874" alt="4" src="https://github.com/LAB-2023/LAB_study/assets/125250173/19245848-1df5-439f-8ec1-7968f7d55461">

커밋하는 시점에 저장됨.

### 준영속

영속성 컨텍스트에서 더 이상 관리하지 않기 때문에 수정하거나 삭제해도 **DB에 반영되지 않는다.**

<img width="718" alt="5" src="https://github.com/LAB-2023/LAB_study/assets/125250173/ff8d723d-b2d0-4d6c-9598-11b1d4f6e096">

### 삭제

**Detached**는 생성되건 수정되건 삭제되건 간에 쿼리가 아예 나가지 않고, **Removed**는 **DELETE** 쿼리가 나간다.

<img width="432" alt="6" src="https://github.com/LAB-2023/LAB_study/assets/125250173/732eddab-c851-4c01-9be2-3e058eb6cc32">

## 이점

- 1차 캐시
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

### 1차 캐시

이 캐시는 **DB와 사용자 사이에서 엔티티를 저장**해주는 역할

<img width="636" alt="7" src="https://github.com/LAB-2023/LAB_study/assets/125250173/a6298982-8bf2-4af6-ace4-a2864b0429a9">

1차 캐시는 한 트랜잭션 안에서만 이루어지기 때문에 아주 짧음.

엔티티를 **검색**할 때 **DB**에 **SELECT** 쿼리를 계속 날리는게 아니라 우선 캐시에 엔티티가 있는지 확인한 후, 없을때만 **SELECT** 쿼리를 날리고 만약 있다면 **캐시에서 엔티티를 바로 반환**

### 영속 엔티티의 동일성 보장

- 1차 캐시로 반복 가능한 읽기(REPEAT TABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공
- 엔티티를 캐시에서 조회하기 때문에, 같은 엔티리를 조회하면 완전히 같은 객체가 반환된다.

### 엔티티 등록 시 트랜잭션을 지원하는 쓰기 지연

<img width="346" alt="8" src="https://github.com/LAB-2023/LAB_study/assets/125250173/fa5af58f-ecb8-442a-b47d-b18bff1bcea3">

영속성 컨텍스트에는 1차 캐시 외에도 **"쓰기 지연 SQL 저장소"** 가 존재한다.

우리가 엔티티를 등록, 수정, 삭제할 때마다 1차 캐시에 반영되는 동시에 쓰기 지연 SQL 저장소에 실행해야될 SQL들이 쌓이는 것이다.

<img width="677" alt="9" src="https://github.com/LAB-2023/LAB_study/assets/125250173/bdeba227-7f03-4bb5-a0ef-792da5c1e032">

<img width="611" alt="10" src="https://github.com/LAB-2023/LAB_study/assets/125250173/5ad397ed-0c8d-47a7-ae67-8fb9673452f3">

commit하거나 flush를 강제 호출할 때 쌓여있던 SQL들이 한번에 DB로 전송된다.

===================이 먼저 출력되고 나머지 쿼리문이 한꺼번에 디비에 보내짐

⇒ 버퍼링 기능 : 한번에 모았다가 디비에 보내기

persistance.xml

```jsx
<property name="hibernate.jdbc.batch_size" value="10"/>
```

### 엔티티 수정 : 변경 감지

1차 캐시에는 **"스냅샷"** 이라는 별도의 공간이 있는데, **SELECT** 쿼리 수행 시 결과를 스냅샷에 저장하고, **flush** 할 때 Entity와 비교하기 위한 용도로 사용된다.

영속성 컨텍스트를 **flush**하는 시점에 엔티티와 스냅샷을 비교하고, 스냅샷과 다른 부분에 대해 자동으로 **UPDATE** 쿼리를 실행한다.

<img width="456" alt="11" src="https://github.com/LAB-2023/LAB_study/assets/125250173/a1fff6e9-9043-43fc-930b-8400afd43fc8">

엔티티와 스냅샷을 비교하여 변경된 점을 발견 → 반영

---

# 플러시

영속성 컨텍스트의 변경내용을 데이터베이스에 반영

## 플러시 발생

- 변경 감지
- 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
- 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

em.flush()를 실행하면 커밋전에 미리 쿼리문을 볼 수 있다. → 바로 반영

Q : flush를 하면 1차캐시 다 지워지나요?

A : 1차 캐시는 유지, 쓰기지연 SQL 저장소가 DB에 바로 반영될 뿐이다.

쉽게 얘기해서 영속성 컨텍스트의 변경 사항들과 DB의 상태를 맞추는 작업이다.
플러시는 영속성 컨텍스트의 변경 내용을 DB에 동기화한다.

### JPQL 쿼리 실행 시 플러시가 자동으로 호출되는 이유

중간에 JPQL 쿼리로 실행 했을 때 DB에 없으면 문제가 생기므로 자동으로 JPQL을 실행하면 플러시가 자동 호출된다.

### 요약

- 영속성 컨텍스트를 비우지 않음
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
- 트랜잭션이라는 작업 단위가 중요 → 커밋 직전에만 동기화 하면 됨

---

# 준영속 상태

- 영속 → 준영속
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리
- 영속성 컨텍스트가 제공하는 기능을 사용 못함

## 준영속 상태로 만드는 방법

**em.detach()**를 통해 영속성에서 떼어버림 → update 쿼리문이 실행되지 않는다.

- 특정 엔티티만 준영속 상태로 전환 : em.detach(entity)

**em.clear()**을 통해 초기화 하여 member2를 새롭게 다시 쿼리문 실행

- 영속성 컨텍스트를 완전히 초기화 : em.clear()
- 영속성 컨텍스트를 종료 : em.close()
